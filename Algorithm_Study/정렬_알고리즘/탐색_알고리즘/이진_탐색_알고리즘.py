# 이진 탐색 알고리즘
'''
- 전체를 반으로 나눠 대소 비교를 통해 탐색

- 데이터가 정렬되어 있지 않으면 사용이 불가능

- 정렬되어 있는 데이터들을 탐색할 경우 이진 탐색이 더 효율적

- 목록을 한 번 정렬하면 장기적으로 검색 성능이 향상될 수 있으므로 목록이 자주 검색되는 경우에 유용

- 시간 복잡도 : O(log_n)

- 장점 

  - 목록의 크기가 커질수록 목록의 요소를 검색하는데 걸리는 시간이 더 느리게 증가함
  
  - 정렬된 목록이 크거나 검색되는 요소가 목록의 중앙에 위치할 때 잘 작용
  
  - 재귀를 사용하여 성능을 최적화할 수 있음 
  
- 단점 

  - 목록을 정렬해야 하므로 검색 프로세스에 추가 단계가 필요
  
  - 선형 검색에 비해 구현하기가 더 복잡함  
'''

num = [1,5,7,13,50,120,300,320,400,700]

def binary_search(num, target):
    left = 0 # 시작 값
    right = len(num) - 1 # 끝 값
    
    while left <= right:
        mid = (left + right) // 2 # 중간 key 값
        if num[mid] == target:
            return mid 
        # 중간 값이 target 보다 작다면 다음 인덱스로 업데이트해 배열의 왼쪽을 제거
        elif num[mid] < target :
            left = mid + 1
        # 중간 값이 target 보다 크다면 이전 인덱스로 업데이트해 배열의 오른쪽을 제거    
        else : 
            right = mid - 1
    return None

print(binary_search(num, 320))